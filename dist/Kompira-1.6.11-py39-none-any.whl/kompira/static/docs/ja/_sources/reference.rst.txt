**************************************
 Kompira ジョブフロー言語リファレンス
**************************************

:著者: Kompira 開発チーム

.. highlight:: none


イントロダクション
==================

本ドキュメントは、ジョブフロー言語の字句と構文、および、意味について説
明します。組み込み関数、組み込みジョブについての記述は :doc:`library` 
にあります。

構文の表記法
------------

本ドキュメントでは、拡張BNFを用いて構文を示します。拡張BNFは通常のBNFに
加えて、0回以上の繰り返しを表す「*」、1回以上の繰り返しを表す「+」、省
略可能な要素を表す「?」といった記号を用います。また、複数の要素をまとめ
るために丸カッコ「(」と「)」も使用します。

字句構造
========

この章では、ジョブフロー言語の字句構造について規定します。ジョブフロー
言語のプログラムテキストは Unicode で記述します。テキストは、Kompiraの
字句解析器によって、トークンと呼ばれる語彙の単位に区切られます。

.. note::
    ジョブフローのプログラムテキストとして記述できるのは最大 65536 文字です。

コメント
--------

コメントは文字列リテラル内に含まれないハッシュ文字(#)から始まり、行末ま
でになります。コメントは字句解析器によって読み飛ばされます。

空白
----

改行文字、スペース、タブ、フォームフィードは空白として扱われます。空白
は字句解析器によって読み飛ばされます。

識別子
------

識別子(IDENTIFIER)は、以下の正規表現によって定義されます。::

   IDENTIFIER = [^\W0-9]\w*

\\wは任意の Unicode 単語文字にマッチします。これにはあらゆる言語で単語
の一部になりうる文字、数字、およびアンダースコアが含まれます。\\Wは
[^\w]を意味します。識別子の長さに制限はありません。大小文字は区別されま
す。

キーワード
''''''''''

以下の文字の並びは、キーワードとして予約されているため識別子として用い
ることはできません。::

  and             break           case            choice
  continue        elif            else            false
  for             fork            if              in
  not             null            or              pfor
  session         then            true            try
  while

予約済みの識別子クラス
''''''''''''''''''''''

__*__ の形式の識別子は制御変数用にシステムで予約されていて特別な意味が
あります。ジョブフローの予期せぬ動作を引き起こす可能性があるため、ユー
ザーが識別子としてこれらの名前を用いることは避けた方が良いでしょう。

特殊識別子
''''''''''

以下で定義されるように $ で始まる識別子は特殊変数に用いられる特殊識別子
です。::

    SPECIAL_IDENTIFIER = "$" IDENTIFIER

オブジェクトパス
----------------

オブジェクトパスは、Kompiraファイルシステム上のオブジェクトの位置を指し
示します。以下のように定義されています。::

       OBJECT_PATH = RELATIVE_PATH
                   | ("/" | RELATIVE_PATH) PATH_ELEMENT* LAST_PATH_ELEMENT
     RELATIVE_PATH = "./" | "../"
      PATH_ELEMENT = RELATIVE_PATH | IDENTIFIER "/"
 LAST_PATH_ELEMENT = RELATIVE_PATH | IDENTIFIER

.. note::
   単独の "/" もオブジェクトパスとして扱われますが、除算演算子"/" と字
   句解析上は区別がつかないため、字句としてのOBJECT_PATHには含まれませ
   ん。

リテラル
--------

リテラルは、文字列(String)型、バイナリ(Binary)型、整数(Integer)型、浮
動小数型(Float)型、ブール(Boolean)型、ヌル(Null)型、パターン(Pattern)
型の値のソースコード上の表記です。

文字列リテラル(STRING)
''''''''''''''''''''''

文字列リテラルは、一重引用符(')、もしくは、二重引用符(")で囲まれた0個以
上の文字から構成されます。

.. ifconfig:: language == 'ja'

    .. code::

        ""                   # 空文字列
        '"'                  # "を保持した文字列
        '\''                 # 'を保持した文字列
        "This is a string"   # 16文字を保有した文字列
        'これは文字列です'    # 8文字を保有した文字列

.. ifconfig:: language != 'ja'

    .. code::

        ""                   # empty string
        '"'                  # "
        '\''                 # '
        "This is a string"   # String containing 16 characters.


また、対応する3連の一重引用符や二重引用符で囲むこともできます。この場合
には、エスケープされていない改行や引用符を書くことができます。

.. ifconfig:: language == 'ja'

    .. code::

        '''''''              # 'を保持した文字列
        """改行を含む
        文字列"""            # 改行コードを含む文字列

.. ifconfig:: language != 'ja'

    .. code::

        '''''''              # '
        """String containing
        line feed code"""    # String containing line feed code

文字列リテラル中では、エスケープシーケンスを使用することによって、改行
文字やタブ文字など、ある種の表現できない文字を表現することができるよう
になります。

エスケープシーケンスの一覧を以下に示します。

+----------------------+---------------------------+
| エスケープシーケンス | 意味                      |
+======================+===========================+
| \\                   | バックスラッシュ(\)       |
+----------------------+---------------------------+
| \'                   | 一重引用符(')             |
+----------------------+---------------------------+
| \"                   | 二重引用符(")             |
+----------------------+---------------------------+
| \a                   | ASCII端末ベル(BEL)        |
+----------------------+---------------------------+
| \b                   | ASCIIバックスペース(BS)   |
+----------------------+---------------------------+
| \f                   | ASCIIフォームフィード(FF) |
+----------------------+---------------------------+
| \n                   | ASCII行送り(LF)           |
+----------------------+---------------------------+
| \r                   | ASCII復帰(CR)             |
+----------------------+---------------------------+
| \t                   | ASCII水平タブ(TAB)        |
+----------------------+---------------------------+
| \v                   | ASCII垂直タブ(VT)         |
+----------------------+---------------------------+
| \ooo                 | 8進数値 *ooo* を持つ文字  |
+----------------------+---------------------------+
| \xhh                 | 16進数値 *hh* を持つ文字  |
+----------------------+---------------------------+


バイナリリテラル(BINARY)
''''''''''''''''''''''''

バイナリリテラルは、プレフィックス記号bの後に一重引用符(')、もしくは、
二重引用符(")で囲まれた0個以上の文字から構成されます。

.. ifconfig:: language == 'ja'

    .. code::

        b""                   # 空バイナリ
        b'"'                  # "を保持したバイナリ
        b'\''                 # 'を保持したバイナリ
        b"This is a string"   # 16bytesを保有したバイナリ

.. ifconfig:: language != 'ja'

    .. code::

        b""                   # empty binary
        b'"'                  # "
        b'\''                 # '
        b"This is a string"   # binary containing 16 bytes.

文字列リテラルとは異なり、対応する3連の引用符による複数行の記述は使え
ません。また、日本語などの非ASCII文字を含めることもできません。エスケー
プシーケンスは、文字列リテラルと同様に使用することができます。


整数リテラル(INTEGER)
'''''''''''''''''''''

整数リテラルは10進数で表現することができます。以下の字句定義で記述され
ます。::

    INTEGER       = NONZERO_DIGIT DIGIT* | "0"
    DIGIT         = [0-9]
    NONZERO_DIGIT = [1-9]

浮動小数リテラル(FLOAT)
'''''''''''''''''''''''

浮動小数リテラルは整数部と小数部からなる仮数部と指数部から構成される浮
動小数点方式の数の表現です。字句定義で記述されます。::

    FLOAT         = DIGIT+ "." DIGIT* ( [eE] [+-]? DIGIT+ )?
    DIGIT         = [0-9]

以下に例を示します。

.. code::

    3.1415926
    0.5e-3          # 0.0005
    12.3e+2         # 1230.0
    9.E5            # 900000.0


真偽リテラル(BOOLEAN)
'''''''''''''''''''''

真偽リテラルはブール型の真(true)と偽(false)の2つの値の表記があります。::

    BOOLEAN = "true" | "false"

ヌルリテラル(NULL)
'''''''''''''''''''

ヌルリテラルは値が無いことを示す値で、null と表記されます。::

    NULL = "null"

パターンリテラル(PATTERN)
'''''''''''''''''''''''''

パターンリテラルは、パターンの種別を表す 'e', 'g', 'r' のいずれかの文字
に引き続き、一重引用符(')、もしくは、二重引用符(")で囲まれた0個以上の文
字（パターン文字列）からなります。最後にモードを示す 'i' がオプションと
して付加される場合もあります。

.. ifconfig:: language == 'ja'

    .. code::

        r"(From|Subject): "      # 正規表現パターン
        g'*.txt'                 # glob パターン
        e'kompira'i              # 大文字小文字を区別しない完全一致パターン
        r"windows(95|nt|2000)"i  # 大文字小文字を区別しない正規表現パターン

.. ifconfig:: language != 'ja'

    .. code::

        r"(From|Subject): "      # regular expression pattern
        g'*.txt'                 # glob pattern
        e'kompira'i              # case-insensitive exact match pattern
        r"windows(95|nt|2000)"i  # case-insensitive regular expression pattern

パターン文字列内ではエスケープシーケンスは無効となり、そのままの文字と
して扱われます。${identifier} による文字列置換は有効です。

記号
----

記号は、演算子記号(OPERATOR)、結合子記号(COMBINATOR)、デリミタに分類されます。

演算子
''''''

以下のトークンは演算子です。::

    +       -       *       /       %
    <       >       <=      >=      ==      !=      =~      !~

結合子
''''''

以下のトークンは結合子です。::

    ->      =>      ->>     =>>

デリミタ
''''''''

以下のトークンはデリミタです。::

    (   )   {   }   [   ]   |   ,   .   =   >>   <<   ?   ??

値と型
======

Kompira のジョブフロー言語では、整数や文字列、日付など様々な値（データ）
を扱うことができます。値はその種類毎にいくつかの型に分類されます。ある
型の値は暗黙的に別の型に変換される場合があります。たとえば、整数型の値
を文字列型のフィールドに書き込む場合、対応する文字列型の値に暗黙的に変
換されてから書き込まれます。

プリミティブ型
--------------

プリミティブ型は、Kompira のジョブフロー言語が提供する基本的なデータの
型の総称で、整数型、文字列型、ブール型、ヌル型の4つがあります。プリミティ
ブ型の値は、他のプリミティブ型の値と状態が共有されることはありません。

.. data_type:: Integer

整数型(Integer)
'''''''''''''''

整数型は 0 や 1, 1000, -9999 など、整数を表す値の型を取り扱います。
Kompira の整数型は、（メモリの許す限り）範囲に限りはありません。

.. note::
   KompiraオブジェクトのInteger型フィールドは範囲が制限されているため、
   ジョブフローから範囲外のデータをInteger型フィールドに書き込むと実行
   時エラーとなります。

.. data_type:: String

文字列型(String)
''''''''''''''''

文字列型は、"kompira" や "本日は晴天なり" のような文字列の値のための型
です。文字列の各要素は文字です。Kompira のジョブフロー言語では文字型は
存在しません。単一の文字は、要素が1つだけの文字列として表現されます。各
文字は内部的には Unicode で表現されています。

"123" や "-999" など、整数を表す文字列の値を、整数型のフィールドに書き
込む場合、対応する整数型の値に暗黙的に変換されます。

文字列型の値が、ブール型に変換される場合、空文字列("")が false、それ以
外の文字列が true と対応します。したがって、文字列 "false" は ブール型
の true に対応するので注意が必要です。

文字列型のデータは、以下のメソッドを備えています。

.. method:: String.format(*args, **kwargs) : String

    文字列の書式化操作を行います。このメソッドを呼び出す文字列は通常の文字、または、{} で区切られた置換フィールドを含みます。
    それぞれの置換フィールドは位置引数のインデックスナンバー、または、キーワード引数の名前を含みます。
    返り値は、それぞれの置換フィールドが対応する引数の文字列値で置換された文字列のコピーです。

.. method:: String.join(list) : String

    リスト中の文字列を結合した文字列オブジェクトを返します。要素間の区切り文字列は、このメソッドを提供する文字列です。

.. method:: String.find(sub[, start[, end]]) : Integer

    文字列のスライス s[start:end] に部分文字列 sub が含まれる場合、その最小のインデックスを返します。
    オプション引数 start および end はスライス表記と同様に解釈されます。
    sub が見つからなかった場合 -1 を返します。

.. method:: String.rfind(sub[, start[, end]]) : Integer

    文字列中の領域 s[start:end] に sub が含まれる場合、その最大のインデクスを返します。
    オプション引数 start および end はスライス表記と同様に解釈されます。
    sub が見つからなかった場合 -1 を返します。

.. method:: String.startswith(prefix[, start[, end]]) : Boolean

    文字列が指定された prefix で始まるなら true を、そうでなければ false を返します。
    prefix は見つけたい複数の接頭語のリストでも構いません。
    オプションの start があれば、その位置から判定を始めます。
    オプションの end があれば、その位置で比較を止めます。

.. method:: String.encode([encoding]) : Binary

    文字列を指定したencodingで指定されたエンコーディングで符号化したバイト列に変換します。
    encodingの指定を省略した場合は、'utf-8'として符号化されます。

.. method:: String.endswith(prefix[, start[, end]]) : Boolean

    文字列が指定された suffix で終わるなら true を、そうでなければ false を返します。
    suffix は見つけたい複数の接尾語のタプルでも構いません。
    オプションの start があれば、その位置から判定を始めます。
    オプションの end があれば、その位置で比較を止めます。

.. method:: String.lower() : String

    全ての大小文字の区別のある文字が小文字に変換された、文字列のコピーを返します。

.. method:: String.upper() : String

    全ての大小文字の区別のある文字が大文字に変換された、文字列のコピーを返します。

.. method:: String.replace(old, new[, count]) : String

    文字列をコピーし、現れる部分文字列 old 全てを new に置換して返します。
    オプション引数 count が与えられている場合、先頭から count 個の old だけを置換します。

.. method:: String.split([sep[, maxsplit]]) : Array<String>

    文字列を sep をデリミタ文字列として区切った単語のリストを返します。
    maxsplit が与えられていれば、最大で maxsplit 回分割されます。

.. method:: String.rsplit([sep[, maxsplit]]) : Array<String>

    sep を区切り文字とした、文字列中の単語のリストを返します。
    maxsplit が与えられた場合、文字列の 右端 から最大 maxsplit 回分割を行います。

.. method:: String.splitlines([keepends]) : Array<String>

    文字列を改行部分で分解し、各行からなるリストを返します。

.. method:: String.strip([chars]) : String

    文字列の先頭および末尾部分を除去したコピーを返します。
    引数 chars は除去される文字集合を指定する文字列です。

.. data_type:: Binary

バイナリ型(Binary)
''''''''''''''''''

バイナリ型は、バイト列を値とする型です。バイト列は文字列と似ていますが、
バイト列を構成する単位は文字ではなくバイト値(0～255の8bit整数値)となり
ます。

バイナリ型のデータは、以下のメソッドを備えています。

.. method:: Binary.decode([encoding]) : String

    バイト列を指定したencodingで指定されたエンコーディングで解釈して文字列に変換します。
    encodingの指定を省略した場合は、'utf-8'として解釈されます。

.. method:: Binary.hex() : String

    バイト列の各バイト値を2桁の16進表記で表した文字列に変換します。

.. data_type:: Float

浮動小数型(Float)
'''''''''''''''''

浮動小数型は、浮動小数点数を値にとる型です。

.. data_type:: Boolean

ブール型(Boolean)
'''''''''''''''''

ブール型は、真理値の真(true)と偽(false)という2つの値をとる型です。

.. data_type:: Null

ヌル型(Null)
''''''''''''

ヌル型は、null 値のみを持つ型です。

.. data_type:: Pattern

パターン型(Pattern)
'''''''''''''''''''

パターン型は、文字列とマッチングを行うためのパターンを表す値の型です。
パターンの種別は、'r' (正規表現パターン)、'g' (glob パターン)、'e' (完
全一致パターン) の 3 種類あります。また、パターンマッチングのモードとし
て、大文字、小文字を区別しないモード ('i') を組み合わせることもできます。

正規表現パターンは、プログラミング言語 Python の re モジュールの正規表
現に準じています。

glob パターン では、Unix のシェル形式のワイルドカードを用いることができ、
以下の特別な文字に対応しています。

======== ===================================================
パターン 意味
======== ===================================================
\*       すべてにマッチします
?        任意の一文字にマッチします
[seq]    seq にある任意の文字にマッチします
[!seq]   seq にない任意の文字にマッチします
======== ===================================================

完全一致パターンでは文字列以外の値で一致比較することもできます。

パターン型のデータは、以下のメソッドを備えています。

.. method:: Pattern.match(s) : Boolean | Dictionary

    文字列 s とパターンとのマッチングを試みます。マッチした場合は true、
    もしくはパターンが正規表現パターンの場合はマッチした情報を格納した
    辞書を返します。マッチしなかった場合は、false を返します。
    正規表現パターンまたは glob パターンで、s に文字列以外を渡した場合は false を返します。

正規表現パターンがマッチした際に返す辞書データには、以下のエントリが含まれます。

========= ===================================================
キー      意味
========= ===================================================
group     正規表現にマッチした文字列
groups    すべてのサブグループの文字列を含むリスト
groupdict 名前付きグループの辞書
start     マッチの開始位置
end       マッチの終了位置
========= ===================================================

.. versionchanged:: 1.6.8.post1

    正規表現パターンまたは glob パターンで、match(s) メソッドに文字列以外を渡した場合は false を返すようになりました。

複合データ型
------------

複合データ型は、他の型の複数の要素を保持することができるデータの型の総称で、配列型と辞書型および遅延評価配列型の3種類があります。

.. data_type:: Array

配列型(Array)
''''''''''''''

配列型のデータは、要素を1次元に並べたデータ構造で、整数のインデックスで
要素にアクセスすることができます。配列の長さが n の場合、インデックスは
0, 1, ..., n - 1 となります。配列 a の要素 i は a[i] で参照することがで
きます。インデックス i が負の場合、 a[i] は 要素 n+i を参照します。

配列の範囲外の要素にアクセスした場合、実行時エラーとなります。また、配
列は拡張することはできません。

配列型のデータは、以下のメソッドを備えています。

.. method:: Array.add_item(value)

    配列 a の最後にデータ value を追加します。

.. method:: Array.del_item(index)

    配列 a の要素 a[index] を削除します。

.. method:: Array.pop_item([index])

    配列 a の要素 a[index] を削除します。indexが指定されなければ最後の要素を削除します。


.. data_type:: Dictionary

辞書型(Dictionary)
''''''''''''''''''

辞書型のデータは、要素を複合データ型を除く任意の型のキーで関連づけられ
た要素にアクセスすることができるデータ構造です。辞書 d のキー k で関連
づけられた要素は、d[k] で参照することができます。キー k が文字列型の値
で、かつ、識別子(IDENTIFIER)の字句要件を満たす文字列の場合、d.k で参照
することもできます。

辞書に含まれていないキーで要素を参照しようとした場合、実行時のエラーに
なります。書き込みジョブ（後述）によって新しいキーと要素を追加すること
ができます。

辞書型のデータは、以下のメソッドを備えています。

.. method:: Dictionary.del_item(key)

    辞書 d の要素 d[key] を削除します。

.. method:: Dictionary.get_item(key[, default])

    辞書 d の要素 d[key] を取得します。要素 d[key] が存在しない場合、default を返します。default のデフォルト値は null です。

.. method:: Dictionary.pop_item(key[, default])

    辞書 d の要素 d[key] を削除します。要素 d[key] が存在しない場合、default を返します。default が与えられず、かつ、要素 d[key] が存在しない場合は、エラーとなります。

.. method:: Dictionary.get_keys()

    辞書 d のキーのリストを返します。


.. data_type:: LazyArray

遅延評価配列型(LazyArray)
'''''''''''''''''''''''''

遅延評価配列型のデータは配列型と似たデータ構造で、整数インデックスで要素にアクセスすることができます。
ただし、名前が示すようにデータの内容は実際にアクセスしたときにはじめて決まるという特徴があります。

遅延評価配列型はオブジェクトの検索結果などを示す結果として返される型として利用されます。
そのためジョブフローで遅延評価配列型のデータを直接記述することは出来ません。

オブジェクトの検索結果を示す結果として遅延評価配列型が返されたとしても、その時点では指定した検索条件などを内部に持っているだけです。
実際にアクセスしたときにその検索条件でデータベースに問い合わせる、という動きをすることから遅延評価と呼ばれます。
このことから、遅延評価配列型はそのデータにアクセスするタイミングで結果が異なる場合があることに注意してください。

以下では、通常の配列型とは内部的な振る舞いが異なる点について簡単に説明します。

length() 組み込み関数に遅延評価配列型を渡した場合は、その時点での検索条件に該当するオブジェクトの個数をデータベースに問い合わせて返します。
また、遅延評価配列型に整数インデックスで要素にアクセスする場合、アクセスのたびに1件づつデータベースに問い合わせてオブジェクトを返します。

こうした特徴から length() で件数を取得して、その個数によるループ処理で整数インデックスでアクセスすると、個数に応じてデータベースへの問い合わせ回数が増えることになります。

.. code::

    [found = /root.find()] ->
    { for i in length(found) |
        [obj = found[i]] ->
        ...
    }

遅延評価配列型は for ブロック（または pfor ブロック）で反復処理することもできます。
この場合は、ブロック開始時に検索条件に該当するオブジェクトをデータベースに問い合わせて、1件づつメモリに展開されてブロック内部の処理に渡されます。

整数インデックスによる繰り返しアクセスではなく、for ブロックでの反復処理にすることでデータベースへの問い合わせ回数を減らすことができます。

.. code::

    [found = /root.find()] ->
    { for obj in found |
        ...
    }

for ブロック内部では、当該オブジェクトのフィールド値を更新したり、オブジェクトを削除することもできます。

遅延評価配列型は \+ 演算子で配列型（または遅延評価配列型）と結合することができます。
この場合は、その時点での検索条件に該当するオブジェクトをデータベースに全件を問い合わせます。
また、結合された値は通常の配列型となり、すべての要素をメモリ上に持つことになります。
このような全件問い合わせを伴う処理では、該当するオブジェクトの個数が多いほど、処理時間とメモリ使用量が増加することに注意してください。

遅延評価配列型はその特徴から、add_item, del_item, pop_item メソッドなどで要素を追加したり削除したりすることは出来ません。

遅延評価配列型のデータは、以下のメソッドを備えています。

.. method:: LazyArray.delete()

    このメソッドを呼び出した時点で該当するオブジェクトをすべて削除します。
    このメソッドは削除したオブジェクトの個数を返します。

.. versionadded:: 1.6.8

    新たに遅延評価配列型が追加されました。


不透明データ型
--------------

不透明データ型は、データの内部構造が隠ぺいされたデータ型の総称です。ま
た、対応するデータコンストラクタを持たないため、複合データ型のようにジョ
ブフロープログラムのソースコード中の表記によって直接データを生成するこ
とはできません。

.. data_type:: Object

オブジェクト型(Object)
''''''''''''''''''''''

オブジェクト型の値は、Kompira ファイルシステム上のオブジェクトの参照を
表現します。オブジェクト型の値の文字列表現はそのオブジェクトの絶対パス
となります。オブジェクト o のプロパティ p は、o.p で、フィールド f は
o[f] という表記でアクセスすることができます。フィールド f と同名のプロ
パティ名やメソッド名が無ければ、o.f という表記でフィールドを参照できま
す。

Kompiraのオブジェクトは、型オブジェクト(TypeObject) によって定義される
フィールドとメソッドを備えています。詳細はKompiraオブジェクトリファレン
ス（:doc:`library`）を参照してください。

.. data_type:: File

ファイル型(File)
''''''''''''''''

ファイル型の値は、ファイル型フィールドを持つオブジェクトに添付されるファ
イルデータを表します。

ファイル型の値には以下のフィールドが定義されています。

============ ======================================================
フィールド名
============ ======================================================
name         添付ファイル名
data         添付ファイルデータ
size         データサイズ (読み取り専用)
url          ダウンロードURL (読み取り専用)
============ ======================================================

name と data をキーとする辞書データを以下のように更新ジョブに渡すこと
で、ファイル型フィールドに値を書き込む (すなわちジョブフローからファイ
ルを作成する) ことが可能です。

.. code::

   [{'name': 'binary.txt', 'data': b'\xde\xad\xbe\xef \xca\xfe'} >> ./some_obj['attached1']]

基本的に data にはバイナリデータを渡しますが、以下のように文字列を渡す
こともできます。

.. ifconfig:: language == 'ja'

    .. code::

        [{'name': 'some.txt', 'data': 'こんにちは'} >> ./some_obj['attached1']]

.. ifconfig:: language != 'ja'

    .. code::

        [{'name': 'some.txt', 'data': 'Hello'} >> ./some_obj['attached1']]


この場合は、UTF-8 でエンコードされ、バイナリデータとしてファイルに書き
込まれます。

以下のように既存ファイルの名称やデータのみを更新することも可能です。

.. ifconfig:: language == 'ja'

    .. code::

       ['update.txt' >> ./some_obj['attached1']['name']] ->    # ファイル名を "update.txt" に更新
       ['new text' >> ./some_obj['attached1']['data']]         # ファイルデータを "new text" に更新

.. ifconfig:: language != 'ja'

    .. code::

       ['update.txt' >> ./some_obj['attached1']['name']] ->    # Update the file name to "update.txt"
       ['new text' >> ./some_obj['attached1']['data']]         # Update the file data to "new text"

ジョブフローによってファイルを削除する場合は、以下のように null 値を更
新ジョブに渡します。

.. code::

   [null >> ./some_obj['attached1']]

.. data_type:: Datetime

日時型(Datetime)
''''''''''''''''

日時型の値は、日付と時刻の両方を含むデータを表します。

日時型の値は以下の読み取り専用のプロパティを備えています。

.. property:: Datetime.year : Integer

    年を示す値

.. property:: Datetime.month : Integer

    月を示す 1 から 12 までの値

.. property:: Datetime.day : Integer

    1 から与えられた月と年における日数までの値

.. property:: Datetime.hour : Integer

    時を示す 0 から 23 までの値

.. property:: Datetime.minute : Integer

    分を示す 0 から 59 までの値

.. property:: Datetime.second : Integer

    秒を示す 0 から 59 までの値

.. property:: Datetime.weekday : Integer

    月曜日を 0、日曜日を 6 として、曜日を整数で表した値

.. property:: Datetime.date : Date

    日時型データのうち日付部分

.. property:: Datetime.time : Time

    日時型データのうち時刻部分

日時型のデータは、以下のメソッドを備えています。

.. method:: Datetime.format(dt_fmt) : String

    dt_fmt で指定されたフォーマットで日時データを文字列に変換します。フォー
    マットの書式指定は、C言語のstrftime()関数に準じています。

    以下に例を示します。

    .. ifconfig:: language == 'ja'

        .. code::

            [dt = now()] -> print(dt.format('%Y年%m月%d日 %H時%M分%S秒'))

    .. ifconfig:: language != 'ja'

        .. code::

            [dt = now()] -> print(dt.format('%Y-%m-%d %H:%M:%S'))

.. method:: Datetime.isoformat() : String

    `YYYY-MM-DDTHH:mm:ssZ` の形式（ISO 8601 フォーマット）の文字列を返します。
    タイムゾーンは常に UTC となり、`Z` の接尾辞がつきます。

.. data_type:: Date

日付型(Date)
''''''''''''

日付型の値は、日付のデータを表します。

日付型の値は以下の読み取り専用のプロパティを備えています。

.. property:: Date.year : Integer

    年を示す値

.. property:: Date.month : Integer

    月を示す 1 から 12 までの値

.. property:: Date.day : Integer

    日を示す、1 から与えられた月と年における日数までの値

.. property:: Date.weekday : Integer

    月曜日を 0、日曜日を 6 として、曜日を整数で表した値


日付型のデータは、以下のメソッドを備えています。

.. method:: Date.format(dt_fmt) : String

    dt_fmt で指定されたフォーマットで日付データを文字列に変換します。フォー
    マットの書式指定は、C言語のstrftime()関数に準じています。

.. data_type:: Time

時刻型(Time)
''''''''''''

時刻型の値は、時刻のデータを表します。

時刻型の値は以下の読み取り専用のプロパティを備えています。

.. property:: Time.hour : Integer

    時を示す 0 から 23 までの値

.. property:: Time.minute : Integer

    分を示す 0 から 59 までの値

.. property:: Time.second : Integer

    秒を示す 0 から 59 までの値

時刻型のデータは、以下のメソッドを備えています。

.. method:: Time.format(dt_fmt) : String

    dt_fmt で指定されたフォーマットで時刻データを文字列に変換します。フォー
    マットの書式指定は、C言語のstrftime()関数に準じています。

.. data_type:: Timedelta

経過時間型(Timedelta)
'''''''''''''''''''''

経過時間型の値は、日時型の値の差分を表すデータです。日時型の値と経過時
間型の値の間で、加算と減算が可能です。また、日時型の値同士の差分は経過
時間型となります。

経過時間型の値は以下の読み取り専用のプロパティを備えています。

.. property:: Timedelta.days : Integer

    日数

.. property:: Timedelta.seconds : Integer

    秒数

.. property:: Timedelta.microseconds : Integer

    マイクロ秒数

.. property:: Timedelta.total_seconds : Float

    経過時間のトータル秒数

変数
====

変数は値を保持するための記憶領域に付けた名前のことです。Kompira ジョブ
フロー言語における変数は、任意の型の値を保持することができます。

.. note::
   fork や pfor ブロックによって生成された子プロセス同士、あるいは親プ
   ロセスと子プロセスの間では、同じスコープであっても変数は共有されませ
   ん。ただし、子プロセスから、子プロセスが生成された時点の親プロセスの
   スコープの変数を参照する（読み取る）ことは可能です。

ローカル変数
------------

ローカル変数は、ジョブフローのパラメータ、代入ジョブによって導入されま
す。ローカル変数はその変数が導入されるソースコード上の位置によって異な
るスコープを持ちます。

ジョブフロースコープ
''''''''''''''''''''

ジョブフロースコープは、その変数が導入されたジョブの後続の任意のジョブ
から参照できるスコープです。ジョブフローパラメータはジョブフロースコー
プを持ちます。また代入ジョブによって未定義変数が新たに導入された場合に
は、その変数はジョブフロースコープを持ちます。

ジョブフロースコープの変数は、同名の変数が内側のブロックスコープで再定
義された場合、隠されます。

ブロックスコープ
''''''''''''''''

ブロックスコープは、そのブロックの内側からのみ参照できるスコープです。
単純ブロックで定義される変数や、for や pfor ブロックによって導入される
ループ変数は、ブロックスコープを持ちます。

環境変数
--------

.. deprecated:: 1.6
    環境変数はバージョン1.6.0で廃止されました。
    代わりに$ENV状態変数を使用してください。

特殊変数
--------

特殊変数は、システムによってあからじめ定義された特別な意味を持つ変数で
す。

.. _status_variables:

状態変数
''''''''

状態変数はリモートジョブなどの実行結果やステータスコードなどを一時的に
格納するための予約された変数であり、$で始まる変数です。これらの変数は、
Kompiraエンジンによって自動的に値がセットされるものであり、ジョブフロー
の中で明示的に代入を行うことはできません。

状態変数には、以下の種類があります。

======= ============================================
変数名  意味
======= ============================================
$RESULT ジョブの実行結果(標準出力)
$STATUS ジョブの実行ステータス
$ERROR  ジョブ実行のエラーメッセージ(標準エラー出力)
$DEBUG  デバッグ情報
$ENV    環境変数辞書
======= ============================================


.. note::
   ジョブの実行結果の文字コードは自動判別され、適切な文字列に変換されます。
   文字列への変換に失敗した場合、ジョブの実行は失敗とみなされ、エラーを返します。

$ENV 状態変数は、ジョブフロー実行ユーザの設定する環境変数型
(Environment)オブジェクトの環境変数フィールドの辞書が格納されます。

.. _control_variables:

制御変数
''''''''

制御変数は、リモートジョブを実行する際のホスト名やログイン名などを指定
するための変数であり、__*__のように2つ続きのアンダースコア (_)が前後に
付加された形式の変数です。

制御変数はローカル変数として定義することもできますし、環境変数として設
定しておくことも可能です。

制御変数には、以下の種類があります。

.. tabularcolumns:: |\Y{0.25}|\Y{0.75}|
.. table::
    :class: longtable

    ====================== ==============================================================================
    変数名                 意味
    ====================== ==============================================================================
    __realm__              リモートコマンドを実行する管理領域を指定する
    __host__               リモートコマンドの実行ホスト名を指定する
    __conntype__           リモートコマンドの実行ホストの接続種別を指定する。
                           （指定できる接続種別については :ref:`node` を参照）
    __user__               リモートコマンドの実行ユーザー名を指定する
    __password__           パスワードを指定する
    __node__               リモートコマンドを実行するノード情報オブジェクトを指定する
    __account__            リモートコマンドを実行するために必要なアカウント情報オブジェクトを指定する
    __sudo__               sudoモードで実行する場合はtrueにセットする
    __dir__                リモートコマンドの実行ディレクトリを指定する
    __port__               sshポート番号を指定する
    __keyfile__            ssh鍵ファイルパスを指定する
    __passphrase__         ssh鍵ファイルのパスフレーズを指定する
                           (パスフレーズ無しの場合や__password__と同じなら省略可能)
    __timeout__            リモートコマンドがタイムアウトするまでの秒数を指定する
    __proxy__              実行ホストに接続する際の経由ホストを指定する
    __shell__              リモードコマンド実行時に利用するshellを指定する(デフォルト: "/bin/bash")
    __use_shell__          リモートコマンド実行時にshellを利用しない場合はfalseをセットする
    __use_pty__            リモートコマンド実行時にPTYを利用する場合はtrueをセットする
    __use_cache__          リモート接続キャッシュを利用しない場合はfalseをセットする
    __raw_stdout__         標準出力をバイナリとして受け取る場合はtrueをセットする
    __raw_stderr__         標準エラー出力をバイナリとして受け取る場合はtrueをセットする
    __encoding__           標準入出力のエンコードを指定する(デフォルト: "utf-8")
    __winrs_auth_type__    WinRS接続の認証方式を"ntlm"(デフォルト), "credssp"から指定する。
    __winrs_scheme__       WinRS接続のスキームを"https"(デフォルト), "http"から指定する。
    __winrs_use_tlsv1_0__  WinRS接続にてCredSSP認証を行う際にTLS1.0を使用する場合はtrueをセットする。
                           (WindowsServer2008など、TLS1.2を使用出来ない環境向け)
    ====================== ==============================================================================

.. deprecated:: 1.4
    制御変数 __via__ はバージョン1.4.0で廃止されました。
    かわりに__proxy__を使用してください。

.. versionadded:: 1.6.0
    制御変数 __raw_stdout__, __raw_stderr__ が追加されました。

.. versionadded:: 1.6.2.post6
    制御変数 __use_cache__ が追加されました。

.. versionchanged:: 1.6.4
    制御変数 __conntype__ が拡張されて、ネットワーク機器を指定できるようになりました。

.. versionchanged:: 1.6.4
    制御変数 __conntype__ において Windows 機器の指定方法が変更になりました。

.. versionadded:: 1.6.8.post2
    制御変数 __encoding__ が追加されました (1.6.0 以降で利用できます)。

.. note::
    WinRS接続の場合は、__use_cache__ の設定にかかわらず常にリモート接続キャッシュは使用しません。

.. note::
    __dir__ で指定するディレクトリ文字列に ( や )、" や ' など、シェル
    のメタ文字が含まれる場合は、以下のように適切にエスケープする必要が
    あります。::

    [__dir__ = 'somedir\\(foo\\)']

.. note::
    __sudo__ = true かつ __use_shell__ = false のとき、__dir__ は指定できません。

.. note::
    __timeout__ を指定しない場合、もしくは、0 の値を設定した場合、リモー
    トコマンド実行時にタイムアウトはしません。__timeout__ に負の値を設
    定した場合の動作は未定義です。

    .. versionchanged:: 1.4.9

    winrs モードでは、実行しているリモートコマンドが出力を続けている限
    りはタイムアウトしません。すなわち、__timeout__ で指定した秒数の時
    間、出力が無い場合にタイムアウトします。

    .. versionchanged:: 1.5.4.post5

    winrs モードでコマンドの出力があっても __timeout__ で指定した秒数でタイムアウトするようになりました。

.. note::

    .. versionchanged:: 1.4.8.post6

    winrs モードによるリモートコマンド実行では、 __timeout__ で指定した
    値と WinRM 側の MaxTimeoutms で設定した値のうち、より小さい値が適用
    されます。

    .. versionchanged:: 1.5.4.post5

    winrs モードでのコマンド実行において、__timeout__ によるタイムアウト指定が MaxTimeoutms より優先されるようになりました。


式
==

ジョブフロープログラム中の式は、ジョブフローの実行過程の中で評価され、
結果として何らかの値を持ちます。

アトミック式
------------

アトミックな式は、式を構成する基本単位となります。識別子やオブジェクト
パス、リテラルはアトミックな式に含まれます。また、カッコで囲まれた形式
も文法的にはアトミックな式に分類されます。

.. productionlist::
   atomic_expression : IDENTIFIER | OBJECT_PATH | SPECIAL_IDENTIFIER
                     : | `literal`
                     : | `parenth_form`
                     : | `array_expression`
                     : | `dict_expression`

識別子(IDENTIFIER)
''''''''''''''''''

アトミックな式としての識別子は、変数名を表します。変数名を評価すると、
評価時の実行環境の下でその変数名に束縛された値を返します。

オブジェクトパス
''''''''''''''''

オブジェクトパスは、そのパスが指し示すKompiraのオブジェクトを値として返
します。オブジェクトパスが相対パス形式の場合は、相対パスの起点はそのジョ
ブフローオブジェクトが所属するディレクトリとなります。たとえば、ジョブ
フロー /root/test_jobflow の中で、./test_object が指し示すオブジェクト
は、 /root/test_object となります。

オブジェクトが存在しない場合、実行時エラーとなります。

特殊識別子
''''''''''

特殊識別子はジョブ実行後の状態変数を表します。ジョブフロー開始時点で、
$STATUS は 0 に、$RESULT と $ERROR は空文字列("")にそれぞれ初期化されま
す。

リテラル
''''''''

リテラルは、文字列、バイナリ、整数値、浮動小数、真偽値、ヌルがあります。

.. productionlist::
    literal : STRING | BINARY | INTEGER | FLOAT | BOOLEAN | NULL

リテラルを評価すると、そのリテラルが示す値になります。

文字列リテラルの場合、その文字列に含まれる $で前置された変数が展開されます。以下の規則に従います。

* $identifier は置換プレースホルダの指定で、"identifier"というキーへの対応付けに相当します。デフォルトは、"identifier"の部分にはKompiraの識別子が書かれていなければなりません。$の後に識別子に使えない文字が出現すると、そこでプレースホルダ名の指定が終わります。
* ${identifier} は$identifier と同じです。プレースホルダ名の後ろに識別子として使える文字列が続いていて、それをプレースホルダ名の一部として扱いたくない場合に必要な書き方です。

例えば、以下に示すジョブフローを実行すると、コンソールには "Hello Kompira" と出力されます。::

    [name = 'Kompira']
    -> print('Hello $name')

丸カッコ形式
''''''''''''

丸カッコ形式は、囲まれている式を評価し、その値を返します。

.. productionlist::
   parenth_form : "(" `expression` ")"

配列式
''''''

配列式は、角カッコで囲われた式のカンマ区切りの並びです。式の並びは省略
することも可能です。

.. productionlist::
   array_expression : "[" `expression_list`? "]"
   expression_list  : `expression` ("," `expression_list`)*

配列式を評価すると、新たに作成された配列型のデータを値として返します。
配列の各要素は左から右へと順に評価されます。

辞書式
''''''

辞書式は、波カッコで囲われたキーと値のペアのカンマ区切りの並びです。ペ
アの並びは省略することも可能です。ペアが等号で結ばれる場合、キーは識別
子でなくてはなりません。キーが重複している場合はコンパイル時にエラーを
報告します。コロンで結ばれる場合は、キーは任意の式を記述することができ
ます。この場合はキーの重複はチェックされません。

.. productionlist::
   dict_expression : "{" ( `binding_list` | `key_val_list` )? "}"
   binding_list    : `binding` ("," `binding_list`)*
   binding         : IDENTIFIER "=" `expression`
   key_val_list    : `key_val` ("," `key_val_list`)*
   key_val         : `expression` ":" `expression`

辞書式を評価すると、新たに作成された辞書型のデータを値として返します。
カンマ区切りの一連のキーと値のペアが与えられると、その要素は左から右へ
評価され、辞書の項目を定義します。重複したキーを与えると文法エラーとな
ります。

後置式
------

後置式は、式の中で最も結合性が高くなります。

.. productionlist::
   postfix_expression : `attribute_reference`
                      : | `subscript_reference`
                      : | `function_call`
                      : | `atomic_expression`

属性参照
''''''''

属性参照は、後置式の後にドットがあり、さらに識別子が続く形式です。

.. productionlist::
   attribute_reference: `postfix_expression` "." IDENTIFIER

後置式の評価結果は、オブジェクト型でなければいけません。後置式の評価結
果のオブジェクトの識別子で指定された属性が評価結果の値となります。指定
された属性が存在しない場合は、識別子の文字列をキーとしてオブジェクトの
フィールド値となります。そのようなフィールドも存在しない場合は、実行時
エラーとなります。

添字参照
''''''''

角カッコで囲まれた式が後に付いている後置式は、オブジェクトのフィールド
や配列、辞書データから要素を取り出す式を表します。

.. productionlist::
   subscript_reference : `postfix_expression` "[" `expression` "]"

後置式の評価結果は、オブジェクト型、辞書型、配列型のいずれかでなければ
いけません。後置式の評価結果がオブジェクト型か辞書型の場合、角カッコの
中の式の評価結果は文字列型である必要があります。この場合、文字列をキー
としてオブジェクトのフィールドや辞書データの要素が選択されます。後置式
が配列型の場合、角カッコの中の式は整数型である必要があります。この場合、
整数値をインデックスとして該当する配列の要素が選択されます。

キーやインデックスに対応する要素が存在しない場合、実行時エラーとなりま
す。

関数呼び出し
''''''''''''

関数呼び出しは、組み込み関数やライブラリ型オブジェクトで定義された関数、
オブジェクトのメソッドを引数のリストとともに呼び出します。引数リストは
式リストとそれに続く束縛リスト（キーワード引数リスト）から構成され、そ
れぞれ空でもかまいません。

.. productionlist::
   function_call : `postfix_expression` "(" `argument_list`? ")"
   argument_list : `expression_list` ("," "*" `atomic_expression`)?
                 :   ("," `binding_list`)? ("," "**" `atomic_expression`)?
                 : | `binding_list` ("," "**" `atomic_expression`)?
                 : | "*" `atomic_expression` ("," `binding_list`)?
                 :   ("," "**" `atomic_expression`)?
                 : | "**" `atomic_expression`

関数呼び出しの際に構文 \*atomic_expression が使われるなら、
atomic_expression の評価は配列型でなくてはなりません。この配列型の要素
は、追加の固定引数のように扱われます。

関数呼び出しで \**atomic_expression 構文が使われた場合、
atomic_expression の値評価結果は辞書型でなければなりません。辞書の内容
は追加のキーワード引数として扱われます。

引数リストの各要素は、関数呼び出しの前に評価されます。

演算子式
--------

単項演算子
''''''''''

単項演算子には、+ と - があります。単項演算子は右結合となるため、+-xは
+(-x)と同じ意味になります。

.. productionlist::
   unary_expression : `postfix_expression`
                    : | ( "+" | "-" ) `unary_expression`

単項 - 演算子は、引数となる数値の符号を反転します。

単項 + 演算子は、数値引数を変更しません。

乗除演算子
''''''''''

乗除演算子には、 \*, /, %があります。これらはどれも同じ優先順位で、左結
合となります。

.. productionlist::
   multiplicative_expression : `unary_expression`
                             : | `multiplicative_expression` "*" `unary_expression`
                             : | `multiplicative_expression` "/" `unary_expression`
                             : | `multiplicative_expression` "%" `unary_expression`

\* 演算は、引数間の積になります。どちらかの引数が文字列や配列で、一方が
整数の場合、文字列や配列がその数だけ繰り返された値となります。たとえば、
式 'foo' * 3 は'foofoofoo'に評価されます。

/ 演算は、引数間の商になります。ゼロによる除算を行うとエラーとなります。

% 演算は、2つの引数が整数の場合、第1引数を第2引数で除算したときの剰余に
なります。第1引数が文字列で、第2引数が辞書の場合、テンプレート文字列を
置換した結果を返します。

加減演算子
''''''''''

加減演算子には、+, -があります。これらはどれも同じ優先順位で、左結合となります。

.. productionlist::
   additive_expression : `multiplicative_expression`
                       : | `additive_expression` "+" `multiplicative_expression`
                       : | `additive_expression` "-" `multiplicative_expression`

\+ 演算は、引数を加算した値を返します。両引数が文字列や配列の場合、連結
された値を返します。

\- 演算は、引数間で減算を行った値を返します。

比較演算子
''''''''''

比較演算子には、<, >, ==, >=, <=, !=, =~, !~ があります。これらはどれも同じ優先
順位をもっており、左結合となります。

.. productionlist::
    comparison_expression : `additive_expression`
                          : | `comparison_expression` "<" `additive_expression`
                          : | `comparison_expression` ">" `additive_expression`
                          : | `comparison_expression` "==" `additive_expression`
                          : | `comparison_expression` ">=" `additive_expression`
                          : | `comparison_expression` "<=" `additive_expression`
                          : | `comparison_expression` "!=" `additive_expression`
                          : | `comparison_expression` "=~" `additive_expression`
                          : | `comparison_expression` "!~" `additive_expression`

比較の結果はブール型の値 true または false となります。比較はいくらでも
連鎖することができます。たとえば、x < y <= z は x < y and y <= z と等価
になります。ただし、この場合、前者では y はただ一度だけ評価されます。ま
た、x < y <= z と (x < y) <= z は意味が異なります。後者は、x < y 評価し
た結果のブール型の値を z と比較します。

同じ型の値同士の比較の意味は、型によって異なります。

* 整数同士の比較では、算術的な比較が行われます。
* 文字列同士の比較では、辞書的な比較が行われます。
* 配列同士の比較では、対応する各要素の比較結果を使って辞書的な比較が行われます。
* 辞書同士の比較は等価判定のみ定義されています。キーが同じ順序で並んでいて、かつ、キーと値の対応する各要素が等しいときのみ、等価となります。

x != y は not (x == y) と等価です。

=~ は類似比較を行います。意味は型によって異なります。

* パターンと文字列の比較では、パターンマッチによる比較が行われます。
* 文字列とそれ以外の型の比較では、文字列以外の値を文字列化して比較が行われます。
* 配列同士の比較では、対応する各要素を類似比較します。
* 辞書同士の比較は、キーの順序の違いを無視して、各キーに対応する値を類似比較します。
* 上記以外は通常の == による等価比較と同じ結果となります。

x !~ y は not (x =~ y) と等価です。


包含演算子
''''''''''

包含演算子は、in, not in があります。これらはどれも同じ優先順位を持っており、左結合となります。

.. productionlist::
    membership_expression : `comparison_expression`
                          : | `membership_expression` "in" `membership_expression`
                          : | `membership_expression` "not" "in" `membership_expression`

包含演算 x in y は値 x が y の要素として含まれている場合は true、含まれていなければ false を返します。
x not in y は not (x in y) と同じです。

y が配列型以外の値の場合、要素かどうかの判定は以下のとおりになります。

* x と y がともに文字列の場合、x が y の部分文字列の場合に要素とみなされます。
* y が辞書型の値の場合、x が yのキー集合に含まれている場合に要素とみなされます。
* y がディレクトリ/テーブル型オブジェクトの場合、x が y の子オブジェクトの場合に要素とみなされます。

論理演算子
''''''''''

論理演算子には、not, and, or があります。論理演算のコンテキストや式の結
果として真偽値を要求される場合、false, null, 0, 空の文字列(""), 空の配
列([]), 空の辞書({}) は全て偽と解釈されます。それ以外の値は真と解釈され
ます。

.. productionlist::
    logical_not_expression : `membership_expression`
                           : | "not" `membership_expression`
    logical_and_expression : `logical_not_expression`
                           : | `logical_and_expression` "and" `logical_not_expression`
     logical_or_expression : `logical_and_expression`
                           : | `logical_or_expression` "or" `logical_and_expression`
                expression : `logical_or_expression`

演算子 not は、引数が偽である場合には true を、それ以外の場合は false になります。

式 x and y は、式 x と y をそれぞれ評価し、x が偽なら x の評価結果を返
します。それ以外の場合は y の評価結果を返します。

式 x or y は、式 x と y をそれぞれ評価し、x が真なら x の評価結果を返し
ます。それ以外の場合は y の評価結果を返します。

ジョブ
======

ジョブは、コマンドの実行やイベントの待ち合わせ、あるいは繰り返しや条件
分岐などの制御を指示します。ジョブの構文は以下の通りです。

.. productionlist::
    job : `skip_job`
        : | `execution_job`
        : | `assignment_job`
        : | `update_job`
        : | `event_job`
        : | `builtin_job`
        : | `control_job`
        : | `block_job`

スキップジョブ
--------------

スキップジョブは、$STATUS を 0 にセットする以外には何も行いません。

.. productionlist::
    skip_job : "[" "]"


実行ジョブ
----------

実行ジョブは、式を評価した結果の値の型によって、異なる処理を実行します。

.. productionlist::
    execution_job : "[" `expression` ("<<" `expression`)? (":" `argument_list`)? "]"

1番目の式を評価した結果が文字列の場合、実行ジョブは制御文脈に応じて、リ
モートサーバもしくはローカルサーバで文字列をコマンドと解釈して実行しま
す。記号 << に引き続いて2番目の式がある場合、その式の評価結果を文字列と
みなして、コマンドの標準入力に渡されます。

1番目の式を評価した結果がジョブフローオブジェクトの場合、そのジョブフロー
オブジェクトを呼び出します。引数リストがある場合には、リスト中の引数の
式を評価した値がジョブフローのパラメータとして渡されます。

1番目の式を評価した結果がスクリプトオブジェクトの場合、そのスクリプトが
リモート、もしくはローカルサーバで実行されます。記号 << に引き続いて2番
目の式がある場合、その式の評価結果を文字列とみなして、スクリプト実行時
の標準入力に渡されます。引数リストがある場合には、リスト中の引数の式を
評価した値がスクリプトのコマンドライン引数として渡されます。

1番目の式を評価した結果が、Kompiraオブジェクトのメソッドの場合、引数リ
ストをパラメータとして、そのメソッドを呼び出します。

1番目の式を評価した結果が、ライブラリオブジェクトの関数の場合、引数リス
トをパラメータとして、その関数を呼び出します。

.. warning::
   コマンドの文字列の長さ、スクリプトとスクリプトのコマンドライン引数の
   サイズは、112KB に制限されています。この制限を超えた場合、ジョブの実
   行は失敗し、$STATUS に -1 をセットします。


代入ジョブ
----------

代入ジョブは、変数に = の右辺式の評価結果を代入します。

.. productionlist::
    assignment_job : "[" `binding_list` "]"

変数が未定義の場合、ジョブフロースコープを持つ変数が新たに定義され、評
価した値で初期化されます。

更新ジョブ
----------

更新ジョブは、最初の式を評価し、その結果の値で、ターゲット式を評価した
結果の変数やオブジェクト、フィールドの内容を更新します。

.. productionlist::
    update_job : "[" `expression` ">>" `target_expression` "]"
    target_expression : IDENTIFIER | OBJECT_PATH
                      : | `target_expression` "." IDENTIFIER
                      : | `target_expression` "[" `expression` "]"

.. _job-eventjob:

イベントジョブ
--------------

イベントジョブは、最初の式を評価し、その型に応じた待ち合わせをします。

.. productionlist::
    event_job : "<" `expression` (("?" | "??") `expression`)? (":" `argument_list`)? ">"
              : | "<" ">"

イベントジョブは、1つ目の式を評価した結果がチャネルオブジェクト、もしくは、タスクオブジェクトの時、そのオブジェクトのイベントを待ち合わせします。$RESULT には受信したオブジェクトが格納されます。

.. code::

    <./ChannelObject> ->
    [message = $RESULT]

プロセスオブジェクトを渡した場合は、そのプロセスが終了するまで待ち合わせします。
この場合、$RESULTにはプロセスオブジェクトが格納されます。

チャネルやタスク、プロセスオブジェクトを要素とするリストを渡した場合は、いずれかのオブジェクトのイベントを待ち合わせします。
$RESULTには、後述する2つの要素を持つリストが格納されます。
リストの1つ目の要素はイベントが発生したオブジェクト、2つ目の要素は受信したオブジェクトです。

.. code::

    # ./ChannelTable is a Table object that contains Channel objects.
    <./ChannelTable.children> ->
    [chan = $RESULT[0], message = $RESULT[1]]

``?`` の後に式（ガード式）が続く場合、ガード付きのイベントジョブとなります。
この場合、ガード式が評価された結果の値とチャネルのメッセージキューの先頭にあるオブジェクトがマッチした場合のみ、メッセージを受信します。
``??`` の場合も同様ですが、メッセージキューの先頭から順にオブジェクトがマッチするかどうかを調べ、マッチした場合には、それまでのオブジェクトを破棄して、マッチしたオブジェクトを受信します。プロセスオブジェクトを待つ場合、ガードの指定は単に無視されます。

引数リストがある場合、タイムアウト指定となります。
最初の式の値が日時型の場合はタイムアウトする日時が指定され、整数型の場合、タイムアウトまでの秒数が指定されます。
タイムアウトした場合、$STATUS は 1 にセットされます。

パラメータとしてキーワード引数 peek_mode=true を渡すと、受信したメッセージの扱いと結果の構造が変化します。
チャネルオブジェクトに対するイベントジョブで peek_mode=true を指定すると、メッセージ受信時に対象チャネルのメッセージキューの先頭メッセージを（削除せずに）参照して、対象チャネルオブジェクト内で当該メッセージを識別するID値とメッセージ本体を含むリスト [msgid, message] を $RESULT に返します。
このときチャネルから当該メッセージは削除されていないので、再度イベントジョブを実行すると同じメッセージを得ることになります。
メッセージの処理を終えるなど、チャネルから当該メッセージを再取得する必要がなくなった場合は、メッセージIDを指定して :ref:`Channel.delete_message() <channel-delete_message>` を呼び出すことで、当該メッセージを削除することができます。

.. code::

    [chan = ./ChannelObject] ->
    <chan: peek_mode=true> ->
    [msgid = $RESULT[0], message = $RESULT[1]] ->
        ...
    [chan.delete_message: msgid]

peek_mode はガード式と合わせて利用することもできます。
``?`` に続けてガード式を指定してメッセージキューの先頭でマッチした場合は、そのメッセージの [msgid, message] のリストを返します。
``??`` に続けてガード式を指定してメッセージキューの途中でマッチした場合は、先頭からそのメッセージの一つ手前までをメッセージキューから削除して、マッチしたメッセージの [msgid, message] のリストを返します。

リストに対するイベントジョブでも peek_mode を合わせて利用することができますが、得られる結果の構造が少し複雑になることに注意してください。

.. code::

    <[chanA, chanB, chanC]: peek_mode=true> ->
    [chan = $RESULT[0], msgid = $RESULT[1][0], message = $RESULT[1][1]]

リストに対するイベントジョブの結果として得られる「受信したオブジェクト」の部分が、peek_mode によって [msgid, message] のリストになっています。

プロセスオブジェクトに対するイベントジョブで peek_mode=true を指定した場合、プロセスIDとプロセスオブジェクトを含むリスト [pid, process] を $RESULT に返します。
これにより、リストを指定したイベントジョブの呼び出し時にリストにチャネルやプロセスを混在させても、結果の構造が同じになります。

メールチャネルに対するイベントジョブのパラメータとしてキーワード引数 detect_error=true を渡すと、設定の不備やメールサーバの障害などの理由によりメールのフェッチに失敗した場合やメールチャネルが無効化されている場合は、$STATUS を -1 にセットして、イベント待ちが直ちに終了します。
(メールチャネル以外のイベントジョブパラメータに detect_error を渡しても単に無視されます)

空式 ``<>`` の場合、常に発火するイベントとなるため、ジョブフローの実行はただちに継続します。

.. versionchanged:: 1.6.6

    キーワード引数 detect_error が追加されました。 

.. versionchanged:: 1.6.7

    キーワード引数 peek_mode が追加されました。 


組み込みジョブ
--------------

組み込みジョブは、Kompiraの組み込みジョブを呼び出します。

.. productionlist::
    builtin_job : IDENTIFIER "(" `argument_list`? ")"

引数リストがある場合、リストの先頭か順に式が評価され、その結果が組み込
みジョブのパラメータとして渡されます。

Kompira が提供する組み込みジョブの一覧と詳細については、:doc:`library`
を参照してください。

制御ジョブ
----------

制御ジョブは、 break と continue の2つがあります。

.. productionlist ::
    control_job : "continue" | "break"

制御ジョブは、while ブロックと for ブロックの内部でのみ使用することがで
きます。それ以外の場所で使用するとコンパイル時エラーとなります。

continue
''''''''

continue は while/for ブロックの次の繰り返しの先頭に制御を移します。

break
'''''

break は while/for ブロックの繰り返しを中止し、ブロックの後続に制御を移
します。

ブロックジョブ
--------------

ブロックジョブはブロックスコープを新しく作成します。

.. productionlist::
    block_job : `simple_block`
              : | `if_block`
              : | `for_block`
              : | `while_block`
              : | `case_block`
              : | `choice_block`
              : | `fork_block`
              : | `pfor_block`
              : | `session_block`
              : | `try_block`

単純ブロック
''''''''''''

単純ブロックは、変数宣言付きの場合は、そのブロックスコープを持つローカ
ル変数を新規に定義し、そのもとでブロック内のジョブフロー式を実行します。
変数宣言が省略された場合は、単にブロック内のジョブフロー式を実行します。

.. productionlist::
    simple_block : "{" (`binding_list` "|")? `jobflow_expression` "}"

ifブロック
''''''''''

if ブロックは、最初の条件式を評価し、その結果によって処理を分岐します。
条件式が省略された場合、直前のジョブの実行結果である $RESULT の値が使用
されます。

.. productionlist::
    if_block : "{" "if" `expression`? "|" `jobflow_expression` "}"
             : | "{" "if" `expression`? "|" `then_clause` `elif_clause`* `else_clause`? "}"
    then_clause : "then" ":" `jobflow_expression`
    elif_clause : "elif" `expression` ":" `jobflow_expression`
    else_clause : "else" ":" `jobflow_expression`

if ブロックの1番目の形式は、条件式が真の場合にのみブロック内のジョブフ
ロー式が実行されます。

if ブロックの2番目の形式は、最初の条件式が真の場合に、then節のジョブフ
ロー式が実行されます。偽の場合には、次のelif節の条件式が評価され、その
値が真の場合に、elif節のジョブフロー式が実行されます。どの条件式も偽の
場合で、最後のelse節があればelse節のジョブフロー式が実行されます。

caseブロック
''''''''''''

case ブロックは最初の式を評価し、その値と各ケース節のパターン式を評価し
た値とのマッチングが試みられます。マッチングが成功すると、対応する
case 節のジョブフローを実行します。case 節のパターン式がカンマ区切りで
複数記述された場合、どれか一つのパターンとマッチするとマッチング成功と
みなされ、その節のジョブフローが実行されます。


最初の式が省略された場合、直前のジョブの実行結果である $RESULT の値が使
用されます。

.. productionlist::
    case_block : "{" "case" `expression`? "|" `case_clause`+ `else_clause`? "}"
    case_clause : `expression_list` ":" `jobflow_expression`

case 節は、パターン式の後に、区切り記号であるコロン (:) とそのパターン
に合致したときに実行するジョブフロー式が続きます。パターン式を評価した
結果がパターンオブジェクトの場合、そのパターンオブジェクトに応じたマッ
チングが試みられます。パターン式の評価結果が文字列の場合、大文字小文字
を区別する Glob パターンとして扱われます。それ以外の場合は、単純な ==
比較によるマッチングを行います。

パターンは case 節の先頭から順番にマッチングが試みられます。どのパター
ンにもマッチしない場合、else 節があればそのジョブフロー式が実行されます。
else 節が無ければ、マッチングに失敗したとみなされ、 $STATUS に 1 がセッ
トされます。

forブロック
'''''''''''

for ブロックはリストやディレクトリ、テーブルなどの複数の要素を含むオブ
ジェクト内の要素にわたって反復処理を行うために使われます。

.. productionlist::
    for_block : "{" "for" IDENTIFIER "in" `expression` "|" `jobflow_expression` "}"

式は for ブロックの実行時に最初の一度だけ評価されます。式の評価結果は反
復可能なオブジェクトか、もしくは、整数値である必要があり、それ以外の場
合は実行エラーとなります。オブジェクトの各要素は識別子 (IDENTIFIER) で
示されるローカル変数に代入されます。式の評価結果が整数値Nの場合、ローカ
ル変数が 0 から N-1 の範囲で反復します。ただし、N が 0 もしくは負の場合
は反復しません。このローカル変数は for ブロックのスコープを持つため、
for ブロックを抜けた後で参照することはできません。

ジョブフロー式の中で break ジョブが実行されると、ループを終了します。
continue ジョブが実行されると、ジョブフロー式の後続の処理をスキップして
ループを終了します。

for ブロック終了時の $STATUS は常に 0 にセットされます。

whileブロック
'''''''''''''

while ブロックは、式を繰り返し評価し、真であればジョブフロー式を実行し
ます。式が偽であれば、while ブロックは繰り返しを終了します。

.. productionlist::
    while_block : "{" "while" `expression` "|" `jobflow_expression` "}"

ジョブフロー式の中で break ジョブが実行されると、ループを終了します。
continue ジョブが実行されると、ジョブフロー式の後続の処理をスキップして、
式の評価に戻ります。

while ブロック終了時の $STATUS は常に 0 にセットされます。

choiceブロック
''''''''''''''

choice ブロックは複数のイベントジョブを待ち、いずれかが実行可能状態にな
ると、そのイベントジョブに後続するジョブフロー式を実行します。

.. productionlist::
    choice_block : "{" "choice" "|" `eventflow_expression`+ "}"
    eventflow_expression : `event_job` ("->" | "=>" | "->>" | "=>>") `jobflow_expression`

複数のイベントジョブが同時に実行可能状態になった場合は、先頭に近いイベ
ントジョブが優先されます。

forkブロック
''''''''''''

fork ブロックは、ジョブフロー式を子プロセスとして実行開始します。

.. productionlist::
    fork_block : "{" "fork" "|" `jobflow_expression`+ "}"

fork ブロックは detach() していない全ての子プロセスが実行完了するまで待ちます。
fork ブロック終了時の $RESULT には fork ブロックで生成した全ての子プロセスのリストがセットされ、
$STATUS には異常終了した子プロセスの個数がセットされます。
すべての子プロセスが正常終了すると $STATUS は 0 になります。

fork ブロックによって生成されるプロセスが、プロセス数の制限を超える場合、
他のプロセスが実行完了し、プロセス数制限内に収まるまで fork ブロックは
実行を待ちます。

pforブロック
''''''''''''

pfor ブロックはリストやディレクトリ、テーブルなどの複数の要素を含むオブ
ジェクト内の要素について、子プロセスを生成して並行処理を行います。

.. productionlist::
    pfor_block : "{" "pfor" IDENTIFIER "in" `expression` "|" `jobflow_expression` "}"

式は pfor ブロックの実行時に最初の一度だけ評価されます。式の評価結果は
反復可能なオブジェクトである必要があり、それ以外の場合は実行エラーとな
ります。オブジェクトの各要素について子プロセスが生成され、各子プロセス
中で対応する要素が識別子 (IDENTIFIER) で示されるローカル変数に代入され
て、子プロセスの実行が開始されます。式の評価結果が整数値Nの場合、ローカ
ル変数が 0 から N-1 のそれぞれで子プロセスの実行が開始されます。ただし、
N が 0 もしくは負の場合、子プロセスは実行されません。

pfor ブロックは detach() していない全ての子プロセスの実行が終了するまで待ちます。
pfor ブロック終了時の $RESULT には pfor ブロックで生成した全ての子プロセスのリストがセットされ、
$STATUS には異常終了した子プロセスの個数がセットされます。
すべての子プロセスが正常終了すると $STATUS は 0 になります。

pfor ブロックによって生成されるプロセスが、プロセス数の制限を超える場合、
他のプロセスが実行完了し、プロセス数制限内に収まるまで pfor ブロックは
実行を待ちます。

session ブロック
''''''''''''''''

session ブロックは、リモートサーバとのセッションを開始します。

.. productionlist::
    session_block : "{" "session" IDENTIFIER "|" `jobflow_expression` "}"


セッションブロックが実行されると、まず、制御変数によって指定されたリモー
トサーバとのセッションを開始します。セッションでリモートサーバとのやり
とりを行うためのセッションチャネルが、識別子 (IDENTIFIER) で示されるロー
カル変数に代入されます。このセッションチャネルに対して、文字列を送信
(send) すると、リモートサーバ側に文字列が送信されます。また、リモートサー
バ側からの出力を取得するには、イベントジョブを用いてセッションチャネル
からデータを取得します。リモートサーバからの出力は行単位のメッセージと
してセッションチャネルに格納されていきます。したがって、セッションチャ
ネルからのメッセージの読み込みは 1 行ずつとなります。

セッションブロックを抜けるとセッションが終了し、とセッションチャネルが
クローズされます。以後、セッションチャネルに対する送信はエラーとなりま
す。また、セッションチャネルからのメッセージの読み込みもエラーとなりま
す。(ただし、セッションクローズまでにリモートサーバから出力されたメッセー
ジは読み込むことができます)

セッションブロック内で break を呼び出すと、セッションをクローズして、ブ
ロックを終了します。

セッションブロックが正常に終了すると、$STATUS に 0 がセットされます。ま
た、$RESULT には、セッションチャネルが格納されます。セッションチャネル
の data 属性には、未読み込みのデータが格納されます。（メッセージの各行
は連結され、1 つの文字列データとなります)

セッションの開始に失敗した場合は、セッションブロックの中は実行されずに
セッションブロックは終了し、$STATUS には 非 0 がセットされます。また、
$ERROR にはエラーの原因を示すメッセージが格納されます。

.. note::
    セッションブロック内で、コマンドジョブを実行することは可能ですが、別の
    セッションを新たに開始することはできません。


以下では、su コマンドを実行して、対話的に処理を行うジョブフローのプログ
ラム例を示します。

.. ifconfig:: language == 'ja'

    .. code::

        [__host__ = 'server.exmaple.com', __user__ = 'testuser', __password__ = 'password',
         __use_pty__ = true   # su コマンド実行には PTY が必要なため true にセット
        ] ->
        # server.example.com にログインしてセッションを開始
        { session s |
            [s.send: 'LANG=C su\n'] ->               # su コマンドを実行
            <s ?? 'Password: '> ->                   # パスワードプロンプトを待つ
            [s.send: 'root_password\n'] ->           # root のパスワードを送信
            <s ?? g'*]# '> ->                        # root プロンプトを待つ
            [s.send: 'service httpd restart\n'] ->   # httpd サービスを再起動
            <s ?? g'*]# '> ->                        # root プロンプトを待つ
            [s.send: 'exit\n']                       # root を 抜ける
        } ->
        print('OK')

.. ifconfig:: language != 'ja'

    .. code::

        [__host__ = 'server.exmaple.com', __user__ = 'testuser', __password__ = 'password',
         __use_pty__ = true   # su command require PTY.
        ] ->
        # log in to server.example.com and start session.
        { session s |
            [s.send: 'LANG=C su\n'] ->               # execute su command
            <s ?? 'Password: '> ->                   # wait for password prompt
            [s.send: 'root_password\n'] ->           # send root's password
            <s ?? g'*]# '> ->                        # wait for root user prompt
            [s.send: 'service httpd restart\n'] ->   # restart the httpd service
            <s ?? g'*]# '> ->                        # wait for root user prompt
            [s.send: 'exit\n']                       # exit from root
        } ->
        print('OK')


tryブロック
'''''''''''

try ブロックは、ブロック内のジョブフロー実行中に発生した異常終了をキャッ
チして、処理を続行します。

.. productionlist::
    try_block : "{" "try" "|" `jobflow_expression` "}"

try ブロックで囲まれたジョブフローが正常に終了した場合は、try ブロック
は $STATUS に 0 をセットし、 異常終了した場合は、$STATUS に 1 をセット
します。また、$DEBUG にデバッグ情報を格納します。

try ブロック内のジョブフローを実行中に exit が呼び出された場合は、ジョ
ブフローは常に終了します。また、try ブロック内のジョブフローを実行中に、
ユーザーによってジョブフローの実行が中止された場合も、ジョブフローは実
行を終了します。


ジョブフロー式
==============

ジョブフロー式は、ジョブを結合子で結びつけた式です。

.. productionlist::
    jobflow_expression : `jobflow_expression` "->" `job`
                       : | `jobflow_expression` "=>" `job`
                       : | `jobflow_expression` "->>" `job`
                       : | `jobflow_expression` "=>>" `job`

.. _ref-connector:

結合子
------

結合子には複数の種類があり、ジョブが失敗した場合にジョブフローの処理を
継続するかどうかが異なります。

以下に結合子の一覧と、ジョブが失敗した時の振る舞い、処理を継続する場合
の状態変数の値を示します。

=========== ====================== ===============================
 結合子      コマンド異常終了時    リモートログイン失敗時
=========== ====================== ===============================
->          | 強制終了             | 強制終了
=>          | 処理継続             | 強制終了
            | $STATUS >= 1         |
            | $RESULT = (stdout)   |
            | $ERROR  = (empty)    |
->>         | 強制終了             | 処理継続
            |                      | $STATUS = -1
            |                      | $RESULT = (empty)
            |                      | $ERROR  = (error message)
=>>         | 処理継続             | 処理継続
            | $STATUS >= 1         | $STATUS = -1
            | $RESULT = (stdout)   | $RESULT = (empty)
            | $ERROR  = (empty)    | $ERROR  = (error message)
=========== ====================== ===============================

リモートコマンドの実行ステータスが0以外の場合は、上表の「コマンド異常終
了時」の動作となります。このとき、リモートコマンドの実行ステータスの値
が $STATUS の値となります。

リモートアクセスがタイムアウトした場合や、ジョブフロー上で指定されたIPアドレス、ユー
ザ名、パスワード等が正しくなかった場合は、上表の「リモートログイン失敗
時」の動作となります。

.. note::

    Windows ノードに対してリモートコマンドを実行したとき、その実行ステータスは
    本来は符号あり32bit値ですが、Kompira では符号なし32bit値として扱います。

.. note::
    1つのジョブフロー式で結合できるジョブの最大数は 4096 個です。
    ブロックの中は別カウントになるので、例えば以下のジョブフロー式では 6 個となります。

    .. code::

        x -> y -> { if true | a -> b -> c } -> z -> v -> w

.. versionchanged:: 1.5.4.post5

    リモートログイン失敗時の $ERROR にはエラーの原因を示すメッセージが格納されます。

ジョブフロープログラム
======================

ジョブフロープログラムは、0個以上のパラメータ宣言とそれに続くジョブフロー
式から構成されます。ジョブフロー式が空の場合は、ジョブフロープログラム
は実行省略することができます。

.. productionlist::
    jobflow_program : (`parameter_declaration`)* `jobflow_expression`?

パラメータ宣言
--------------

パラメータ宣言は、以下の形式をとります。

.. productionlist::
    parameter_declaration : "|" IDENTIFIER ("=" `expression`)? "|"

パラメータ宣言で、parameter_declaration = expresssion の形式がある場合、
そのジョブフローはデフォルトのパラメータを持ちます。デフォルト値を持つ
パラメータに対しては、ジョブフロー呼び出しの際に対応するパラメータが省
略されると、パラメータの値はデフォルト値で置き換えられます。デフォルト
パラメータ式は、ジョブフロー呼び出しのたびに値評価されます。
